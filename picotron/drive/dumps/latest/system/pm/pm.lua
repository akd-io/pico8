--[[

	procman.lua

	Process Manager

	doesn't have much to do!
	process slices are run from the kernel mainloop

]]


function _update()

	-- to do: adjust process cpu allocations based on previous frame
	
	-- headless script: shutdown when no userland processes remaining
	if (stat(315) > 0 and #_get_process_list() <= 3) _signal(33)

	-- exported player: shutdown when no userland processes remaining
	-- to do: this test no longer works
	if (stat(317) > 0 and #_get_process_list() <= 3) _signal(33)

end


local file_subscribers = {}

-- request from a userland process to subscribe to a file
-- generated by on_event("modified:...", ...)
-- to do: periodically sweep dead process ids from file_subscribers 
on_event("_subscribe_to_file",
	function(msg)
		local fn = msg.filename_kernal -- if filename is garbage, will just never be triggered		
		if (type(fn) ~= "string" or type(msg.filename_userland) ~= "string") return
		--printh("_subscribe_to_file "..pod{msg})
		file_subscribers[fn] = file_subscribers[fn] or {}
		add(file_subscribers[fn], {proc_id = msg._from, filename_userland = msg.filename_userland})
	end
)

-- generated by store()
on_event("_file_stored",
	function(msg)
		local subscribers = file_subscribers[msg.filename]
		if (not subscribers) return
		for i=1, #subscribers do
			-- printh("sending to subscriber "..pod(subscribers[i]))
			send_message(subscribers[i].proc_id,
			{
				event = "modified:"..subscribers[i].filename_userland,
				filename = subscribers[i].filename_userland,
				proc_id = msg.proc_id
			})
		end
	end
)

-- some settings (e.g. fullscreen) need to be observed by the runtime on change
on_event("modified:/appdata/system/settings.pod", function(msg)
	_apply_system_settings(fetch(msg.filename))
end)



on_event("kill_process", 
	function(msg)

		-- silentely refuse to kill system processes: kernel, process manager, window manager
		-- commented; fun to kill these processes! can have useful error screen when core processes have crashed
		-- if (msg.proc_id < 3) return

--		printh("killing process via message "..tostr(msg.proc_id))

		_kill_process(msg.proc_id)

	end
)

on_event("restart_process", 
	function(msg)
		-- printh("[pm.lua] restart_process: "..msg.proc_id)
		_kill_process(msg.proc_id, 1) -- 1 means restart
		send_message(msg.proc_id, {event = "unpause"})
	end
)


on_event("open_host_path", 
	function(msg)
		_open_host_path(msg.path)
	end
)

-- placeholder; to do: allow communication by program name?
on_event("broadcast",
	function (msg)

		local pl = _get_process_list()

		for i=1,#pl do
			if (pl[i].id > 3) then
				send_message(pl[i].id, msg.msg)
			end
		end

	end
)

-- to do: care about who is asking!
on_event("shutdown",
	function()
		_signal(33)
	end
)

on_event("reboot",
	function()
		_signal(34)
	end
)

on_event("mount_host_desktop",
	function()
		_signal(65)
	end
)

on_event("export",

	function(msg)
		-- cart info in a format exporter can read easily

		if ((msg._flags & 0x1) == 0) return -- invoked by a trusted system app (/system/tools/export.lua)

		memset(0,0,4096)

		poke(0x000, ord(msg.shortname, 1, min(#msg.shortname,255)))
		poke(0x100, ord(msg.outfile, 1, min(#msg.outfile,255)))
		poke(0x200, ord(msg.cartfile, 1, min(#msg.cartfile,255)))
		if (type(msg.export_home) == "string") then
			poke(0x300, ord(msg.export_home, 1, min(#msg.export_home,255)))
		end

		-- current active palette for icon: use wm palette
		for i=0,255 do
			poke(0x400+i, _ppeek(3,0x5000+i))
		end

		if (msg.icon) then 
			-- icon width, height
			poke(0x500, msg.icon:width(), msg.icon:height()) -- only 16x16 supported in 0.2 though
			poke(0x800, msg.icon:get(0,0,256))			
		else
			-- to do: default icon here
			
		end

		_signal(42)

	end

)



